// ASS-Sort - Sort ASS subtitles events
// Copyright (c) 2019 Slek

#define PROGRAM_NAME "ass_sort"
#define PROGRAM_DESC "Sort ASS subtitles events."
#define PROGRAM_ARGS "input output"
#define PROGRAM_VERS "1.0"
#define COPY_INFO "Copyright (c) 2019 Slek"

#define FLAGS_CASES                                                                                \

#include <cmath>
#include <cstdint>
#include <functional>
#include <fstream>
#include <iostream>
#include <limits>
#include <map>
#include <sstream>
#include <string>
#include <unordered_set>
#include <vector>

#include "ass.hpp"
#include "flags.hpp"
#include "util/string.h"
#include "util/version.h"

inline void sort(const ass::ASSFile& ass, ass::ASSFile& out) {
  out.clear();

  out.BOM() = ass.BOM();
  out.LineBreak() = ass.LineBreak();
  out.ScriptComment() = ass.ScriptComment();

  bool has_events = false;
  std::map<ass::time_t, std::list<std::pair<std::string, std::string>>> event_lines;
  for (const std::string& section : ass.Sections()) {
    if (section == ass::EVENTS) {
      has_events = true;

      const std::list<std::pair<std::string, std::string>>& lines = ass.Section(ass::EVENTS);

      std::list<std::pair<std::string, std::string>>::const_iterator it = lines.cbegin();
      if (it == lines.cend()) continue;

      const std::pair<std::string, std::string>& format_line = *it;
      out.add_line(ass::EVENTS, format_line.first, format_line.second);
      ++it;

      if (format_line.first != "Format")
        throw ass::io_error("format line must appear first in events");

      std::size_t text_idx = std::numeric_limits<std::size_t>::max();
      if (!ass::get_field_index(format_line.second, "Text", &text_idx) ||
           (text_idx != (StringSplit(format_line.second, ass::FIELD_DELIMITER).size()-1)))
        throw ass::io_error("'Text' field must appear in last place");

      std::size_t start_idx = std::numeric_limits<std::size_t>::max();
      if (!ass::get_field_index(format_line.second, "Start", &start_idx))
        throw ass::io_error("'Start' field not found in format definition string");

      for (; it != lines.cend(); ++it) {
        const std::string& line_type = it->first;
        const std::string& line_data = it->second;

        bool start_defined = false;
        ass::time_t start_ts = std::numeric_limits<ass::time_t>::max();

        std::string::size_type start_begin, start_end;
        if (ass::get_field(line_data, start_idx, &start_begin, &start_end)) {
          if (start_begin < start_end) {
            start_ts = ass::parse_time(line_data.substr(start_begin, start_end - start_begin));
            start_defined = true;
          }
        } else throw ass::io_error("'Start' field cannot be retrieved");

        if (!start_defined) {
          out.add_line(ass::EVENTS, line_type, line_data);
          continue;
        }

        event_lines[start_ts].push_back(std::make_pair(line_type, line_data));
      }
    } else {
      out.insert(section, ass.Section(section));
    }
  }

  if (!has_events)
    std::cerr << "[WARNING] Events section not found!" << std::endl;
  else {
    for (const std::pair<ass::time_t, std::list<std::pair<std::string, std::string>>>& entry : event_lines) {
      for (const std::pair<std::string, std::string>& line : entry.second)
        out.add_line(ass::EVENTS, line.first, line.second);
    }
  }
}

int main(int argc, char* argv[]) {

  if (flags::HelpRequired(argc, argv)) {
    flags::ShowHelp();
    return 0; // SUCCESS
  }

  if (flags::VersionRequested(argc, argv)) {
    flags::ShowVersion();
    return 0; // SUCCESS
  }

  int result = flags::ParseFlags(&argc, &argv, true);
  if (result > 0) {
    std::cerr << "unrecognized option '" << argv[result] << "'" << std::endl;
    std::cerr << "Try '" << PROGRAM_NAME << " --help' for more information" << std::endl;
    return 1; // FAILURE
  }

  if (argc != 3) {
    flags::ShowHelp();
    return 1; // FAILURE
  }

  std::ifstream input(argv[1]);
  if (!input.is_open()) {
    std::cerr << "[ERROR] Can't open input file!" << std::endl;
    return 1; // FAILURE
  }

  std::ofstream output(argv[2]);
  if (!output.is_open()) {
    std::cerr << "[ERROR] Can't open output file!" << std::endl;
    return 1; // FAILURE
  }

  ass::ASSFile ass_input;
  ass_input.load(input);

  const std::string build = StringPrintf("; Script generated by ASSTools (%s)", GetBuildInfo().c_str());
  const std::string url = "; http://github.com/Slek-Z/ass_tools";
  ass_input.ScriptComment() = build + ass_input.LineBreak() + url;

  ass::ASSFile ass_output;
  sort(ass_input, ass_output);

  output << ass_output;

  return 0; // SUCCESS
}
