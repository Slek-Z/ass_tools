// ASS-Merge - Merge ASS subtitles
// Copyright (c) 2019 Slek

#define PROGRAM_NAME "ass_merge"
#define PROGRAM_DESC "Merge ASS subtitles."
#define PROGRAM_ARGS "in1 in2 [delay] output"
#define PROGRAM_VERS "1.0"
#define COPY_INFO "Copyright (c) 2019 Slek"

#define FLAGS_CASES                                                                                \

#include <cmath>
#include <cstdint>
#include <fstream>
#include <iostream>
#include <iterator>
#include <limits>
#include <sstream>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <vector>

#include "ass.hpp"
#include "flags.hpp"
#include "util/string.h"
#include "util/version.h"

inline void merge(const ass::ASSFile& ass1, const ass::ASSFile& ass2, const ass::time_t t, ass::ASSFile& merged) {
  merged.clear();

  // BOM
  if (ass1.BOM() || ass2.BOM()) merged.BOM() = true;
  else merged.BOM() = false;

  // Line break
  if (ass1.LineBreak() != ass2.LineBreak()) merged.LineBreak() = ass::LINE_SEPARATOR;

  // Script comment
  const std::string build = StringPrintf("; Script generated by ASSTools (%s)", GetBuildInfo().c_str());
  const std::string url = "; http://github.com/Slek-Z/ass_tools";
  merged.ScriptComment() = build + merged.LineBreak() + url;

  { // [ScriptInfo]
    const std::unordered_set<std::string> strict = {"ScriptType"};
    const std::unordered_set<std::string> whitelist = {"Title", "Original Script"};
    const std::unordered_set<std::string> optional = {"Original Translation", "Original Editing", "Original Timing", "Synch Point", "Script Updated By", "Update Details"};

    std::unordered_map<std::string, std::string> type_map2;
    for (const std::pair<std::string, std::string>& entry : ass2.Section(ass::SCRIPT_INFO))
      type_map2[entry.first] = entry.second;

    std::unordered_set<std::string> types1;
    for (const std::pair<std::string, std::string>& entry : ass1.Section(ass::SCRIPT_INFO)) {
      const std::string& line_type = entry.first;
      const std::string& line_data = entry.second;

      types1.insert(line_type);
      if (type_map2.find(line_type) != type_map2.end()) {
        if (line_data != type_map2.at(line_type)) {
          if (strict.find(line_type) != strict.end()) throw ass::io_error(StringPrintf("'%s' lines must have the same value", line_type.c_str()).c_str());
          if (optional.find(line_type) != optional.end()) continue;
          if (whitelist.find(line_type) != whitelist.end()) {
            merged.add_line(ass::SCRIPT_INFO, line_type, StringPrintf("%s /%s", line_data.c_str(), type_map2.at(line_type).c_str()));
            continue;
          }
          std::cerr << "[WARNING] Couldn't merge '" << line_type << "' line. Keeping only data from first input..." << std::endl;
        }
      }
      merged.add_line(ass::SCRIPT_INFO, line_type, line_data);
    }

    for (const std::pair<std::string, std::string>& entry : ass2.Section(ass::SCRIPT_INFO)) {
      if (types1.find(entry.first) == types1.end())
        merged.add_line(ass::SCRIPT_INFO, entry.first, entry.second);
    }
  }

  // [V4+ Styles]
  if (ass1.HasSection(ass::STYLES) && ass2.HasSection(ass::STYLES)) {
    const std::list<std::pair<std::string, std::string>>& lines1 = ass1.Section(ass::STYLES);
    const std::list<std::pair<std::string, std::string>>& lines2 = ass2.Section(ass::STYLES);

    if (lines1.front().first != "Format" || lines2.front().first != "Format")
      throw ass::io_error("format line must appear first");

    std::vector<std::size_t> permutation;
    const std::string& format1 = lines1.front().second, format2 = lines2.front().second;
    if (format1 != format2)
      permutation = ass::compute_permutation(format1, format2);

    // Format
    merged.add_line(ass::STYLES, "Format", format1);

    std::size_t name_idx = std::numeric_limits<std::size_t>::max();
    if (!ass::get_field_index(format1, "Name", &name_idx))
      throw ass::io_error("'Name' field not found in format definition string");

    std::unordered_map<std::string, std::string> names1;
    for (std::list<std::pair<std::string, std::string>>::const_iterator it = std::next(lines1.cbegin()); it != lines1.cend(); ++it) {
      const std::string& line_type = it->first;
      const std::string& line_data = it->second;

      merged.add_line(ass::STYLES, line_type, line_data);

      // Get field Name
      std::string::size_type name_begin, name_end;
      if (!ass::get_field(line_data, name_idx, &name_begin, &name_end))
        throw ass::io_error("'Name' field cannot be retrieved");
      std::string name = line_data.substr(name_begin, name_end - name_begin);
      StringTrim(&name);
      names1[name] = line_data;
    }

    // Merge
    for (std::list<std::pair<std::string, std::string>>::const_iterator it = std::next(lines2.cbegin()); it != lines2.cend(); ++it) {
      const std::string& line_type = it->first;
      std::string line_data = it->second; // copy!

      if (!permutation.empty()) {
        std::vector<std::string> permuted;
        if (!ass::apply_permutation(StringSplit(line_data, ass::FIELD_DELIMITER), permutation, permuted))
          throw ass::io_error("can't perform field permutation");
        line_data.clear();
        for (const std::string& str : permuted)
          line_data += str;
      }

      // Check for collisions
      std::string::size_type name_begin, name_end;
      if (!ass::get_field(line_data, name_idx, &name_begin, &name_end))
        throw ass::io_error("'Name' field cannot be retrieved");
      std::string name = line_data.substr(name_begin, name_end - name_begin);
      StringTrim(&name);

      std::unordered_map<std::string, std::string>::const_iterator mit = names1.find(name);
      if (mit != names1.end()) {
        if (mit->second != line_data)
          throw ass::io_error(StringPrintf("'%s' colliding style", name.c_str()).c_str());
      } else merged.add_line(ass::STYLES, line_type, line_data);
    }
  } else if (ass1.HasSection(ass::STYLES)) {
    merged.insert(ass::STYLES, ass1.Section(ass::STYLES));
  } else if (ass2.HasSection(ass::STYLES)) {
    merged.insert(ass::STYLES, ass2.Section(ass::STYLES));
  }

  // [Fonts] & [Graphics]
  for (const std::string& section : {ass::FONTS, ass::GRAPHICS}) {
    if (ass1.HasSection(section) && ass2.HasSection(section)) {
      std::unordered_map<std::string, const std::string*> m1; // Use reference to avoid copy (big data here)
      for (const std::pair<std::string, std::string>& entry : ass1.Section(section)) {
        const std::string& line_data = entry.second;
        std::string::size_type pos = line_data.find(ass1.LineBreak());
        if (pos == std::string::npos) continue; // No data? Useless line...
        merged.add_line(section, entry.first, line_data);
        std::string name = line_data.substr(0, pos);
        StringTrim(&name);
        m1[name] = &line_data;
      }

      for (const std::pair<std::string, std::string>& entry : ass2.Section(section)) {
        const std::string& line_data = entry.second;
        std::string::size_type pos = line_data.find(ass2.LineBreak());
        if (pos == std::string::npos) continue; // No data? Useless line...
        std::string name = line_data.substr(0, pos);
        StringTrim(&name);
        std::unordered_map<std::string, const std::string*>::const_iterator mit = m1.find(name);
        if (mit != m1.end()) {
          if (line_data.compare(*(mit->second)) != 0)
            throw ass::io_error(StringPrintf("'%s' colliding file", name.c_str()).c_str());
        } else merged.add_line(section, entry.first, line_data);
      }
    } else if (ass1.HasSection(section)) {
      merged.insert(section, ass1.Section(section));
    } else if (ass2.HasSection(section)) {
      merged.insert(section, ass2.Section(section));
    }
  }

  // [Events]
  if (ass1.HasSection(ass::EVENTS) && ass2.HasSection(ass::EVENTS)) {
    const std::list<std::pair<std::string, std::string>>& lines1 = ass1.Section(ass::EVENTS);
    const std::list<std::pair<std::string, std::string>>& lines2 = ass2.Section(ass::EVENTS);

    if (lines1.front().first != "Format" || lines2.front().first != "Format")
      throw ass::io_error("format line must appear first");

    std::vector<std::size_t> permutation;
    const std::string& format1 = lines1.front().second, format2 = lines2.front().second;
    if (format1 != format2)
      permutation = ass::compute_permutation(format1, format2);

    std::size_t text_idx = std::numeric_limits<std::size_t>::max();
    if (!ass::get_field_index(format1, "Text", &text_idx) ||
         (text_idx != (StringSplit(format1, ass::FIELD_DELIMITER).size()-1)))
      throw ass::io_error("'Text' field must appear in last place");

    std::size_t start_idx = std::numeric_limits<std::size_t>::max();
    if (!ass::get_field_index(format1, "Start", &start_idx))
      throw ass::io_error("'Start' field not found in format definition string");

    std::size_t end_idx = std::numeric_limits<std::size_t>::max();
    if (!ass::get_field_index(format1, "End", &end_idx))
      throw ass::io_error("'End' field not found in format definition string");

    merged.insert(ass::EVENTS, ass1.Section(ass::EVENTS));

    for (std::list<std::pair<std::string, std::string>>::const_iterator it = std::next(lines2.cbegin()); it != lines2.cend(); ++it) {
      const std::string& line_type = it->first;
      const std::string& line_data = it->second;

      ass::time_t start_ts = std::numeric_limits<ass::time_t>::max(),
        end_ts = std::numeric_limits<ass::time_t>::max();
      bool start_defined = false, end_defined = false;

      std::string::size_type start_begin, start_end;
      if (ass::get_field(line_data, start_idx, &start_begin, &start_end)) {
        if (start_begin < start_end) {
          start_ts = ass::parse_time(line_data.substr(start_begin, start_end - start_begin));
          start_ts += t;
          start_defined = true;
        }
      } else throw ass::io_error("'Start' field cannot be retrieved");

      std::string::size_type end_begin, end_end;
      if (ass::get_field(line_data, end_idx, &end_begin, &end_end)) {
        if (end_begin < end_end) {
          end_ts = ass::parse_time(line_data.substr(end_begin, end_end - end_begin));
          end_ts += t;
          end_defined = true;
        }
      } else throw ass::io_error("'End' field cannot be retrieved");

      // End ignored in command and sound events
      if ((line_type == ass::COMMAND_EVENT) || (line_type == ass::SOUND_EVENT)) end_defined = false;

      std::string start_str, end_str;
      if (start_defined)
        start_str = ass::format_time(start_ts);
      if (end_defined)
        end_str = ass::format_time(end_ts);

      std::stringstream event_data_stream;
      if (start_begin < end_begin) {
        event_data_stream << line_data.substr(0, start_begin)
                          << start_str
                          << line_data.substr(start_end, end_begin-start_end)
                          << end_str
                          << line_data.substr(end_end);
      } else if (end_begin < start_begin) {
        event_data_stream << line_data.substr(0, end_begin)
                          << end_str
                          << line_data.substr(end_end, start_begin-end_end)
                          << start_str
                          << line_data.substr(start_end);
      } else throw ass::io_error("unexpected error");

      merged.add_line(ass::EVENTS, line_type, event_data_stream.str());
    }
  } else if (ass1.HasSection(ass::EVENTS)) {
    merged.insert(ass::EVENTS, ass1.Section(ass::EVENTS));
  } else if (ass2.HasSection(ass::EVENTS)) {
    merged.insert(ass::EVENTS, ass2.Section(ass::EVENTS));
  }
}

int main(int argc, char* argv[]) {

  if (flags::HelpRequired(argc, argv)) {
    flags::ShowHelp();
    return 0; // SUCCESS
  }

  if (flags::VersionRequested(argc, argv)) {
    flags::ShowVersion();
    return 0; // SUCCESS
  }

  int result = flags::ParseFlags(&argc, &argv, true);
  if (result > 0) {
    std::cerr << "unrecognized option '" << argv[result] << "'" << std::endl;
    std::cerr << "Try '" << PROGRAM_NAME << " --help' for more information" << std::endl;
    return 1; // FAILURE
  }

  if (argc < 4 || argc > 5) {
    flags::ShowHelp();
    return 1; // FAILURE
  }

  std::ifstream input1(argv[1]);
  if (!input1.is_open()) {
    std::cerr << "[ERROR] Can't open first input file!" << std::endl;
    return 1; // FAILURE
  }

  std::ifstream input2(argv[2]);
  if (!input2.is_open()) {
    std::cerr << "[ERROR] Can't open second input file!" << std::endl;
    return 1; // FAILURE
  }

  std::uint32_t offset_ts = 0;
  std::ofstream output;
  if (argc == 5) {
    double offset = std::stod(argv[3]);
    if (!std::isfinite(offset) || offset < 0.0) {
      std::cerr << "[ERROR] Invalid offset!" << std::endl;
      return 1; // FAILURE
    }
    offset_ts = static_cast<std::uint32_t>(offset * 100.);

    output.open(argv[4]);
  } else {
    output.open(argv[3]);
  }

  if (!output.is_open()) {
    std::cerr << "[ERROR] Can't open output file!" << std::endl;
    return 1; // FAILURE
  }

  ass::ASSFile ass1, ass2;
  ass1.load(input1);
  ass2.load(input2);

  ass::ASSFile merged;
  merge(ass1, ass2, offset_ts, merged);

  output << merged;

  return 0; // SUCCESS
}
