// ASS-Extract - Extract ASS subtitles by styles
// Copyright (c) 2019 Slek

#define PROGRAM_NAME "ass_extract"
#define PROGRAM_DESC "Extract ASS subtitles by styles."
#define PROGRAM_ARGS "input styles output"
#define PROGRAM_VERS "1.0"
#define COPY_INFO "Copyright (c) 2019 Slek"

#define FLAGS_CASES                                                                                \
    FLAG_CASE(except, -1, "extract all styles except the specified ones")

#include <cmath>
#include <cstdint>
#include <functional>
#include <fstream>
#include <iostream>
#include <limits>
#include <sstream>
#include <string>
#include <unordered_set>
#include <vector>

#include "ass.hpp"
#include "flags.hpp"
#include "util/string.h"
#include "util/version.h"

inline void extract(const ass::ASSFile& ass, const std::unordered_set<std::string>& styles, ass::ASSFile& out, std::function<bool(const std::unordered_set<std::string>&, const std::string&)> comparator) {
  out.clear();

  out.BOM() = ass.BOM();

  out.ScriptComment() = ass.ScriptComment();

  bool has_events = false;
  for (const std::string& section : ass.Sections()) {
    if (section == ass::EVENTS) {
      has_events = true;

      const std::list<std::pair<std::string, std::string>>& lines = ass.Section(ass::EVENTS);

      std::list<std::pair<std::string, std::string>>::const_iterator it = lines.cbegin();
      if (it == lines.cend()) continue;

      const std::pair<std::string, std::string>& format_line = *it;
      out.add_line(ass::EVENTS, format_line.first, format_line.second);
      ++it;

      if (format_line.first != "Format")
        throw ass::io_error("format line must appear first in events");

      std::size_t text_idx = std::numeric_limits<std::size_t>::max();
      if (!ass::get_field_index(format_line.second, "Text", &text_idx) ||
           (text_idx != (StringSplit(format_line.second, ass::FIELD_DELIMITER).size()-1)))
        throw ass::io_error("'Text' field must appear in last place");

      std::size_t style_idx = std::numeric_limits<std::size_t>::max();
      if (!ass::get_field_index(format_line.second, "Style", &style_idx))
        throw ass::io_error("'Style' field not found in format definition string");

      for (; it != lines.cend(); ++it) {
        if (it->first != ass::DIALOGUE_EVENT) continue;

        const std::string& line_data = it->second;

        std::string style;
        std::string::size_type style_begin, style_end;
        if (ass::get_field(line_data, style_idx, &style_begin, &style_end)) {
          if (style_begin < style_end) {
            style = line_data.substr(style_begin, style_end - style_begin);
          }
        } else throw ass::io_error("'Style' field cannot be retrieved");

        if (comparator(styles, style))
          out.add_line(ass::EVENTS, ass::DIALOGUE_EVENT, line_data);
      }
    } else {
      out.insert(section, ass.Section(section));
    }
  }

  if (!has_events)
    std::cerr << "[WARNING] Events section not found!" << std::endl;
}

int main(int argc, char* argv[]) {

  if (flags::HelpRequired(argc, argv)) {
    flags::ShowHelp();
    return 0; // SUCCESS
  }

  if (flags::VersionRequested(argc, argv)) {
    flags::ShowVersion();
    return 0; // SUCCESS
  }

  int result = flags::ParseFlags(&argc, &argv, true);
  if (result > 0) {
    std::cerr << "unrecognized option '" << argv[result] << "'" << std::endl;
    std::cerr << "Try '" << PROGRAM_NAME << " --help' for more information" << std::endl;
    return 1; // FAILURE
  }

  if (argc != 4) {
    flags::ShowHelp();
    return 1; // FAILURE
  }

  std::ifstream input(argv[1]);
  if (!input.is_open()) {
    std::cerr << "[ERROR] Can't open input file!" << std::endl;
    return 1; // FAILURE
  }

  std::vector<std::string> styles = StringSplit(argv[2], ass::FIELD_DELIMITER);
  std::unordered_set<std::string> styles_set;
  for (std::string& style : styles) {
    StringTrim(&style);
    styles_set.insert(style);
  }

  std::ofstream output(argv[3]);
  if (!output.is_open()) {
    std::cerr << "[ERROR] Can't open output file!" << std::endl;
    return 1; // FAILURE
  }

  std::function<bool(const std::unordered_set<std::string>&, const std::string&)> comparator = (FLAGS_except) ?
      ([](const std::unordered_set<std::string>& set, const std::string& str) {
        std::string str_trimmed = str;
        StringTrim(&str_trimmed);

        return set.find(str_trimmed) == set.cend();
      })
    :
      ([](const std::unordered_set<std::string>& set, const std::string& str) {
        std::string str_trimmed = str;
        StringTrim(&str_trimmed);

        return set.find(str_trimmed) != set.cend();
      });

  ass::ASSFile ass_input;
  ass_input.load(input);

  const std::string build = StringPrintf("; Script generated by ASSTools (%s)", GetBuildInfo().c_str());
  const std::string url = "; http://github.com/Slek-Z/ass_tools";
  ass_input.ScriptComment() = build + ass_input.LineBreak() + url;

  ass::ASSFile ass_output;
  extract(ass_input, styles_set, ass_output, comparator);

  output << ass_output;

  return 0; // SUCCESS
}
